{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, Point, Signature, signSync, utils } from '@noble/secp256k1';\nimport { Buffer, bytesToHex, hexToBigInt, intToHex, parseRecoverableSignatureVrs, privateKeyToBuffer, PRIVATE_KEY_COMPRESSED_LENGTH, signatureRsvToVrs, signatureVrsToRsv } from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { addressFromVersionHash, addressHashModeToVersion, addressToString, createMessageSignature } from './common';\nimport { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, PubKeyEncoding, StacksMessageType, TransactionVersion, UNCOMPRESSED_PUBKEY_LENGTH_BYTES } from './constants';\nimport { BufferArray, hash160, hashP2PKH } from './utils';\n\nutils.hmacSha256Sync = function (key) {\n  const h = hmac.create(sha256, key);\n\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport function getAddressFromPrivateKey(privateKey) {\n  let transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\nexport function getAddressFromPublicKey(publicKey) {\n  let transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\nexport function createStacksPublicKey(key) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex')\n  };\n}\nexport function publicKeyFromSignatureVrs(message, messageSignature) {\n  let pubKeyEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubKeyEncoding.Compressed;\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(message, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\nexport function publicKeyFromSignatureRsv(message, messageSignature) {\n  let pubKeyEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubKeyEncoding.Compressed;\n  return publicKeyFromSignatureVrs(message, Object.assign(Object.assign({}, messageSignature), {\n    data: signatureRsvToVrs(messageSignature.data)\n  }), pubKeyEncoding);\n}\nexport const publicKeyFromSignature = publicKeyFromSignatureVrs;\nexport function publicKeyFromBuffer(data) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data\n  };\n}\nexport function isCompressed(key) {\n  return !key.data.toString('hex').startsWith('04');\n}\nexport function publicKeyToString(key) {\n  return key.data.toString('hex');\n}\nexport function serializePublicKey(key) {\n  const bufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\nexport function pubKeyfromPrivKey(privateKey) {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\nexport function compressPublicKey(publicKey) {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\nexport function deserializePublicKey(bufferReader) {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)]));\n}\nexport function createStacksPrivateKey(key) {\n  const data = privateKeyToBuffer(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return {\n    data,\n    compressed\n  };\n}\nexport function makeRandomPrivKey() {\n  return createStacksPrivateKey(bytesToHex(utils.randomPrivateKey()));\n}\nexport function signWithKey(privateKey, messageHash) {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true\n  });\n\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();\n  return createMessageSignature(recoverableSignatureString);\n}\nexport function signMessageHashRsv(_ref) {\n  let {\n    messageHash,\n    privateKey\n  } = _ref;\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return Object.assign(Object.assign({}, messageSignature), {\n    data: signatureVrsToRsv(messageSignature.data)\n  });\n}\nexport const parseRecoverableSignature = parseRecoverableSignatureVrs;\nexport function getPublicKey(privateKey) {\n  return pubKeyfromPrivKey(privateKey.data);\n}\nexport function privateKeyToString(privateKey) {\n  return privateKey.data.toString('hex');\n}\nexport function publicKeyToAddress(version, publicKey) {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}","map":{"version":3,"mappings":"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","names":["hmac","sha256","getPublicKey","nobleGetPublicKey","Point","Signature","signSync","utils","Buffer","bytesToHex","hexToBigInt","intToHex","parseRecoverableSignatureVrs","privateKeyToBuffer","PRIVATE_KEY_COMPRESSED_LENGTH","signatureRsvToVrs","signatureVrsToRsv","c32address","addressFromVersionHash","addressHashModeToVersion","addressToString","createMessageSignature","AddressHashMode","COMPRESSED_PUBKEY_LENGTH_BYTES","PubKeyEncoding","StacksMessageType","TransactionVersion","UNCOMPRESSED_PUBKEY_LENGTH_BYTES","BufferArray","hash160","hashP2PKH","hmacSha256Sync","key","h","create","msgs","forEach","msg","update","digest","getAddressFromPrivateKey","privateKey","transactionVersion","Mainnet","pubKey","pubKeyfromPrivKey","getAddressFromPublicKey","data","publicKey","toString","addrVer","SerializeP2PKH","addr","from","addrString","createStacksPublicKey","type","PublicKey","publicKeyFromSignatureVrs","message","messageSignature","pubKeyEncoding","Compressed","parsedSignature","signature","r","s","point","fromSignature","recoveryId","compressed","toHex","publicKeyFromSignatureRsv","Object","publicKeyFromSignature","publicKeyFromBuffer","isCompressed","startsWith","publicKeyToString","serializePublicKey","bufferArray","push","concatBuffer","privKey","createStacksPrivateKey","slice","compressPublicKey","hex","fromHex","deserializePublicKey","bufferReader","fieldId","readUInt8","keyLength","concat","readBuffer","length","makeRandomPrivKey","randomPrivateKey","signWithKey","messageHash","rawSignature","canonical","recovered","Error","recoveryIdHex","recoverableSignatureString","toCompactHex","signMessageHashRsv","parseRecoverableSignature","privateKeyToString","publicKeyToAddress","version"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\keys.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey as nobleGetPublicKey,\n  Point,\n  Signature,\n  signSync,\n  utils,\n} from '@noble/secp256k1';\nimport {\n  Buffer,\n  bytesToHex,\n  hexToBigInt,\n  intToHex,\n  parseRecoverableSignatureVrs,\n  privateKeyToBuffer,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  signatureRsvToVrs,\n  signatureVrsToRsv,\n} from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { BufferReader } from './bufferReader';\nimport {\n  addressFromVersionHash,\n  addressHashModeToVersion,\n  addressToString,\n  createMessageSignature,\n  MessageSignature,\n} from './common';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n} from './constants';\nimport { BufferArray, hash160, hashP2PKH } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Buffer;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key buffer or hex string */\n  privateKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key buffer or hex string */\n  publicKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex'),\n  };\n}\n\nexport function publicKeyFromSignatureVrs(\n  message: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(message, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\n\nexport function publicKeyFromSignatureRsv(\n  message: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  return publicKeyFromSignatureVrs(\n    message,\n    { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) },\n    pubKeyEncoding\n  );\n}\n\n/**\n * @deprecated use {@link publicKeyFromSignatureRsv} (recommended) or {@link publicKeyFromSignatureVrs} instead\n */\nexport const publicKeyFromSignature = publicKeyFromSignatureVrs;\n\nexport function publicKeyFromBuffer(data: Buffer): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !key.data.toString('hex').startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return key.data.toString('hex');\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Buffer): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\n\nexport function compressPublicKey(publicKey: string | Buffer): StacksPublicKey {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\n\nexport function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(\n    Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)])\n  );\n}\n\nexport interface StacksPrivateKey {\n  // \"compressed\" private key is a misnomer: https://web.archive.org/web/20220131144208/https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#comp_priv\n  // it actually means: should public keys be generated as \"compressed\" or \"uncompressed\" from this private key\n  compressed: boolean;\n  data: Buffer;\n}\n\nexport function createStacksPrivateKey(key: string | Buffer): StacksPrivateKey {\n  const data = privateKeyToBuffer(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(): StacksPrivateKey {\n  return createStacksPrivateKey(bytesToHex(utils.randomPrivateKey()));\n}\n\n/**\n * @deprecated The Clarity compatible {@link signMessageHashRsv} is preferred, but differs in signature format\n * @returns A recoverable signature (in VRS order)\n */\nexport function signWithKey(privateKey: StacksPrivateKey, messageHash: string): MessageSignature {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true,\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex(); // V + RS\n  return createMessageSignature(recoverableSignatureString);\n}\n\n/**\n * Signs a message using a private key. The resulting signature along with the\n * original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signMessageHashRsv({\n  messageHash,\n  privateKey,\n}: {\n  messageHash: string;\n  privateKey: StacksPrivateKey;\n}): MessageSignature {\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\n}\n\n/**\n * @deprecated\n * This method is now exported from `@stacks/common` {@link parseRecoverableSignatureVrs}\n */\nexport const parseRecoverableSignature = parseRecoverableSignatureVrs;\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return privateKey.data.toString('hex');\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n"]},"metadata":{},"sourceType":"module"}