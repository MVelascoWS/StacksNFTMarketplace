{"ast":null,"code":"import { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { compressPublicKey, deserializePublicKey, serializePublicKey } from './keys';\nimport { createMessageSignature } from './common';\nimport { BufferArray } from './utils';\nexport var AuthFieldType;\n\n(function (AuthFieldType) {\n  AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n  AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\n\nexport function deserializeMessageSignature(bufferReader) {\n  return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents\n  };\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\nexport function serializeMessageSignature(messageSignature) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\nexport function serializeTransactionAuthField(field) {\n  const bufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n\n      break;\n\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}","map":{"version":3,"mappings":"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","names":["DeserializationError","PubKeyEncoding","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","compressPublicKey","deserializePublicKey","serializePublicKey","createMessageSignature","BufferArray","AuthFieldType","deserializeMessageSignature","bufferReader","readBuffer","toString","createTransactionAuthField","pubKeyEncoding","contents","type","TransactionAuthField","deserializeTransactionAuthField","authFieldType","readUInt8Enum","n","PublicKeyCompressed","Compressed","PublicKeyUncompressed","Uncompressed","SignatureCompressed","SignatureUncompressed","Error","JSON","stringify","serializeMessageSignature","messageSignature","bufferArray","appendHexString","data","concatBuffer","serializeTransactionAuthField","field","PublicKey","appendByte","push","MessageSignature"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\signature.ts"],"sourcesContent":["import { BufferReader } from './bufferReader';\nimport { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport {\n  compressPublicKey,\n  deserializePublicKey,\n  serializePublicKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { createMessageSignature, MessageSignature } from './common';\n\n// @ts-ignore\nimport { Buffer } from '@stacks/common';\nimport { BufferArray } from './utils';\n\nexport enum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature {\n  return createMessageSignature(\n    bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex')\n  );\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializePublicKey(bufferReader)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bufferReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n"]},"metadata":{},"sourceType":"module"}