{"ast":null,"code":"import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { serializeMessageSignature, deserializeMessageSignature } from './signature';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList } from './types';\nimport { createStacksPublicKey, getPublicKey, isCompressed, publicKeyFromSignature, signWithKey } from './keys';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\nexport function emptyMessageSignature() {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex')\n  };\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature()\n  };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs\n  };\n}\nexport function isSingleSig(condition) {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition) {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return Object.assign(Object.assign({}, cloned), {\n    nonce: BigInt(0),\n    fee: BigInt(0)\n  });\n}\n\nexport function serializeSingleSigSpendingCondition(condition) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError('Failed to parse singlesig spending condition: incomaptible hash mode and key encoding');\n  }\n\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature\n  };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField).values;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Failed to parse multisig spending condition: too many signatures');\n        break;\n    }\n  }\n\n  const signaturesRequired = bufferReader.readUInt16BE();\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired\n  };\n}\nexport function serializeSpendingCondition(condition) {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\nexport function deserializeSpendingCondition(bufferReader) {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n  const hashLength = 32 + 1 + 8 + 8;\n  const sigHash = curSigHash + Buffer.from([authType]).toString('hex') + intToBytes(fee, false, 8).toString('hex') + intToBytes(nonce, false, 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n  const pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n  const sigHashBuffer = Buffer.from(sigHash, 'hex');\n\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    nextSig: signature,\n    nextSigHash\n  };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n  const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    pubKey: publicKey,\n    nextSigHash\n  };\n}\n\nfunction newInitialSigHash() {\n  const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(condition, initialSigHash, authType) {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\n\nfunction verifySingleSig(condition, initialSigHash, authType) {\n  const {\n    pubKey,\n    nextSigHash\n  } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n  return nextSigHash;\n}\n\nfunction verifyMultiSig(condition, initialSigHash, authType) {\n  const publicKeys = [];\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of condition.fields) {\n    let foundPubKey;\n\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        foundPubKey = field.contents;\n        break;\n\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const {\n          pubKey,\n          nextSigHash\n        } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents);\n        curSigHash = nextSigHash;\n        foundPubKey = pubKey;\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n        break;\n    }\n\n    publicKeys.push(foundPubKey);\n  }\n\n  if (numSigs !== condition.signaturesRequired) throw new VerificationError('Incorrect number of signatures');\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);\n  return curSigHash;\n}\n\nexport function createStandardAuth(spendingCondition) {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition\n  };\n}\nexport function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition ? sponsorSpendingCondition : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0)\n  };\n}\nexport function intoInitialSighashAuth(auth) {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n\n  throw new Error('Authorization missing SpendingCondition');\n}\nexport function verifyOrigin(auth, initialSigHash) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\nexport function setFee(auth, amount) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = Object.assign(Object.assign({}, auth.spendingCondition), {\n        fee: intToBigInt(amount, false)\n      });\n      return Object.assign(Object.assign({}, auth), {\n        spendingCondition\n      });\n\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = Object.assign(Object.assign({}, auth.sponsorSpendingCondition), {\n        fee: intToBigInt(amount, false)\n      });\n      return Object.assign(Object.assign({}, auth), {\n        sponsorSpendingCondition\n      });\n  }\n}\nexport function getFee(auth) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\nexport function setNonce(auth, nonce) {\n  const spendingCondition = Object.assign(Object.assign({}, auth.spendingCondition), {\n    nonce: intToBigInt(nonce, false)\n  });\n  return Object.assign(Object.assign({}, auth), {\n    spendingCondition\n  });\n}\nexport function setSponsorNonce(auth, nonce) {\n  const sponsorSpendingCondition = Object.assign(Object.assign({}, auth.sponsorSpendingCondition), {\n    nonce: intToBigInt(nonce, false)\n  });\n  return Object.assign(Object.assign({}, auth), {\n    sponsorSpendingCondition\n  });\n}\nexport function setSponsor(auth, sponsorSpendingCondition) {\n  const sc = Object.assign(Object.assign({}, sponsorSpendingCondition), {\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false)\n  });\n  return Object.assign(Object.assign({}, auth), {\n    sponsorSpendingCondition: sc\n  });\n}\nexport function serializeAuthorization(auth) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(auth.authType);\n\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n\n    case AuthType.Sponsored:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bufferArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializeAuthorization(bufferReader) {\n  const authType = bufferReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n  let spendingCondition;\n\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      return createStandardAuth(spendingCondition);\n\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","intToBigInt","intToBytes","AddressHashMode","AuthType","PubKeyEncoding","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","BufferArray","cloneDeep","leftPadHex","txidFromData","serializeMessageSignature","deserializeMessageSignature","addressFromPublicKeys","createEmptyAddress","createLPList","deserializeLPList","serializeLPList","createStacksPublicKey","getPublicKey","isCompressed","publicKeyFromSignature","signWithKey","DeserializationError","SigningError","VerificationError","emptyMessageSignature","type","MessageSignature","data","alloc","toString","createSingleSigSpendingCondition","hashMode","pubKey","nonce","fee","signer","hash160","keyEncoding","Compressed","Uncompressed","signature","createMultiSigSpendingCondition","numSigs","pubKeys","stacksPublicKeys","map","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","BigInt","serializeSingleSigSpendingCondition","bufferArray","appendByte","appendHexString","push","concatBuffer","serializeMultiSigSpendingCondition","writeUInt16BE","deserializeSingleSigSpendingCondition","bufferReader","readBuffer","readUInt8Enum","n","SerializeP2WPKH","deserializeMultiSigSpendingCondition","TransactionAuthField","values","haveUncompressed","field","contents","PublicKey","pubKeyEncoding","readUInt16BE","SerializeP2SH","serializeSpendingCondition","deserializeSpendingCondition","SerializeP2PKH","makeSigHashPreSign","curSigHash","authType","hashLength","sigHash","from","byteLength","Error","makeSigHashPostSign","sigHashBuffer","nextSignature","privateKey","sigHashPreSign","publicKey","nextSigHash","nextSig","nextVerification","initialSigHash","newInitialSigHash","spendingCondition","verify","verifySingleSig","verifyMultiSig","addrBytes","publicKeys","foundPubKey","createStandardAuth","Standard","createSponsoredAuth","sponsorSpendingCondition","Sponsored","repeat","intoInitialSighashAuth","auth","verifyOrigin","setFee","amount","getFee","setNonce","setSponsorNonce","setSponsor","sc","serializeAuthorization","deserializeAuthorization"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\authorization.ts"],"sourcesContent":["import { Buffer, IntegerType, intToBigInt, intToBytes } from '@stacks/common';\nimport {\n  AddressHashMode,\n  AuthType,\n  MultiSigHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport {\n  TransactionAuthField,\n  serializeMessageSignature,\n  deserializeMessageSignature,\n} from './signature';\nimport {\n  addressFromPublicKeys,\n  createEmptyAddress,\n  createLPList,\n  deserializeLPList,\n  serializeLPList,\n} from './types';\n\nimport {\n  createStacksPublicKey,\n  getPublicKey,\n  isCompressed,\n  publicKeyFromSignature,\n  signWithKey,\n  StacksPrivateKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { BufferReader } from './bufferReader';\nimport { MessageSignature } from './common';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n  };\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface SingleSigSpendingConditionOpts\n  extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport interface MultiSigSpendingConditionOpts\n  extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: IntegerType,\n  fee: IntegerType\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: IntegerType,\n  fee: IntegerType\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\nexport function isSingleSig(\n  condition: SpendingConditionOpts\n): condition is SingleSigSpendingConditionOpts {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition: SpendingConditionOpts): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return {\n    ...cloned,\n    nonce: BigInt(0),\n    fee: BigInt(0),\n  };\n}\n\nexport function serializeSingleSigSpendingCondition(\n  condition: SingleSigSpendingConditionOpts\n): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeMultiSigSpendingCondition(\n  condition: MultiSigSpendingConditionOpts\n): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bufferReader: BufferReader\n): SingleSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError(\n      'Failed to parse singlesig spending condition: incomaptible hash mode and key encoding'\n    );\n  }\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bufferReader: BufferReader\n): MultiSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536)\n          throw new VerificationError(\n            'Failed to parse multisig spending condition: too many signatures'\n          );\n        break;\n    }\n  }\n  const signaturesRequired = bufferReader.readUInt16BE();\n\n  // Partially signed multi-sig tx can be serialized and deserialized without exception (Incorrect number of signatures)\n  // No need to check numSigs !== signaturesRequired to throw Incorrect number of signatures error\n\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingConditionOpts): Buffer {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\n\nexport function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    Buffer.from([authType]).toString('hex') +\n    intToBytes(fee, false, 8).toString('hex') +\n    intToBytes(nonce, false, 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKey: StacksPublicKey,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const pubKeyEncoding = isCompressed(pubKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  const sigHashBuffer = Buffer.from(sigHash, 'hex');\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(\n    publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding)\n  );\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    0,\n    0\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(\n  condition: SpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { pubKey, nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // address version arg doesn't matter for signer hash generation\n  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return nextSigHash;\n}\n\nfunction verifyMultiSig(\n  condition: MultiSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const publicKeys: StacksPublicKey[] = [];\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of condition.fields) {\n    let foundPubKey: StacksPublicKey;\n\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        foundPubKey = field.contents;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const { pubKey, nextSigHash } = nextVerification(\n          curSigHash,\n          authType,\n          condition.fee,\n          condition.nonce,\n          field.pubKeyEncoding,\n          field.contents\n        );\n        curSigHash = nextSigHash;\n        foundPubKey = pubKey;\n\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n\n        break;\n    }\n    publicKeys.push(foundPubKey);\n  }\n\n  if (numSigs !== condition.signaturesRequired)\n    throw new VerificationError('Incorrect number of signatures');\n\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  const addrBytes = addressFromPublicKeys(\n    0,\n    condition.hashMode,\n    condition.signaturesRequired,\n    publicKeys\n  ).hash160;\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return curSigHash;\n}\n\nexport type Authorization = StandardAuthorization | SponsoredAuthorization;\n\nexport interface StandardAuthorization {\n  authType: AuthType.Standard;\n  spendingCondition: SpendingCondition;\n}\n\nexport interface SponsoredAuthorization {\n  authType: AuthType.Sponsored;\n  spendingCondition: SpendingCondition;\n  sponsorSpendingCondition: SpendingCondition;\n}\n\nexport function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition,\n  };\n}\n\nexport function createSponsoredAuth(\n  spendingCondition: SpendingCondition,\n  sponsorSpendingCondition?: SpendingCondition\n): Authorization {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition\n      ? sponsorSpendingCondition\n      : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),\n  };\n}\n\nexport function intoInitialSighashAuth(auth: Authorization): Authorization {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n\n  throw new Error('Authorization missing SpendingCondition');\n}\n\nexport function verifyOrigin(auth: Authorization, initialSigHash: string): string {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\n\nexport function setFee(auth: Authorization, amount: IntegerType): Authorization {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = {\n        ...auth.spendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, spendingCondition };\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = {\n        ...auth.sponsorSpendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, sponsorSpendingCondition };\n  }\n}\n\nexport function getFee(auth: Authorization): bigint {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\n\nexport function setNonce(auth: Authorization, nonce: IntegerType): Authorization {\n  const spendingCondition = {\n    ...auth.spendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    spendingCondition,\n  };\n}\n\nexport function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization {\n  const sponsorSpendingCondition = {\n    ...auth.sponsorSpendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition,\n  };\n}\n\nexport function setSponsor(\n  auth: SponsoredAuthorization,\n  sponsorSpendingCondition: SpendingConditionOpts\n): Authorization {\n  const sc = {\n    ...sponsorSpendingCondition,\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition: sc,\n  };\n}\n\nexport function serializeAuthorization(auth: Authorization): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(auth.authType);\n\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n    case AuthType.Sponsored:\n      bufferArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bufferArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAuthorization(bufferReader: BufferReader) {\n  const authType = bufferReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n\n  let spendingCondition;\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      return createStandardAuth(spendingCondition);\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bufferReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}