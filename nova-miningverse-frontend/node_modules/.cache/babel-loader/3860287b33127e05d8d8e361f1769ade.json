{"ast":null,"code":"\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\n\nfunction assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\n\nexports.assertNumber = assertNumber;\n\nfunction chain() {\n  const wrap = (a, b) => c => a(b(c));\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, undefined);\n  const decode = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, undefined);\n  return {\n    encode,\n    decode\n  };\n}\n\nfunction alphabet(alphabet) {\n  return {\n    encode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(i => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i];\n      });\n    },\n    decode: input => {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(letter => {\n        if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    }\n  };\n}\n\nfunction join() {\n  let separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: from => {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n\n      for (let i of from) if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n\n      return from.join(separator);\n    },\n    decode: to => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\n\nfunction padding(bits) {\n  let chr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '=';\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n\n      for (let i of data) if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n\n      while (data.length * bits % 8) data.push(chr);\n\n      return data;\n    },\n\n    decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n\n      for (let i of input) if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n\n      let end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n\n      return input.slice(0, end);\n    }\n\n  };\n}\n\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: from => from,\n    decode: to => fn(to)\n  };\n}\n\nfunction convertRadix(data, from, to) {\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach(d => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n\n  while (true) {\n    let carry = 0;\n    let done = true;\n\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i];\n      const digitBase = from * carry + digit;\n\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n\n      carry = digitBase % to;\n      digits[i] = Math.floor(digitBase / to);\n      if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!digits[i]) pos = i;else done = false;\n    }\n\n    res.push(carry);\n    if (done) break;\n  }\n\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n\n  return res.reverse();\n}\n\nconst gcd = (a, b) => !b ? a : gcd(b, a % b);\n\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\n\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n\n  if (radix2carry(from, to) > 32) {\n    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n  }\n\n  let carry = 0;\n  let pos = 0;\n  const mask = 2 ** to - 1;\n  const res = [];\n\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = carry << from | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n\n    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n\n    carry &= 2 ** pos - 1;\n  }\n\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    }\n  };\n}\n\nfunction radix2(bits) {\n  let revPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\n\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function () {\n    try {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n\n    decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n\n      for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n\n      return payload;\n    }\n\n  };\n}\n\nexports.utils = {\n  alphabet,\n  chain,\n  checksum,\n  radix,\n  radix2,\n  join,\n  padding\n};\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(s => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n\nconst genBase58 = abc => chain(radix(58), alphabet(abc), join(''));\n\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n  encode(data) {\n    let res = '';\n\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n\n    return res;\n  },\n\n  decode(str) {\n    let res = [];\n\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = exports.base58.decode(slice);\n\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n\n    return Uint8Array.from(res);\n  }\n\n};\n\nconst base58check = sha256 => chain(checksum(4, data => sha256(sha256(data))), exports.base58);\n\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\nfunction bech32Polymod(pre) {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n\n  return chk;\n}\n\nfunction bechChecksum(prefix, words) {\n  let encodingConst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const len = prefix.length;\n  let chk = 1;\n\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n\n  chk = bech32Polymod(chk);\n\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n\nfunction genBech32(encoding) {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n\n  const _words = radix2(5);\n\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode(prefix, words) {\n    let limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;\n    if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    prefix = prefix.toLowerCase();\n    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n  }\n\n  function decode(str) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90;\n    if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n    str = lowered;\n    const sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = str.slice(0, sepIndex);\n\n    const _words = str.slice(sepIndex + 1);\n\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return {\n      prefix,\n      words\n    };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str) {\n    const {\n      prefix,\n      words\n    } = decode(str, false);\n    return {\n      prefix,\n      words,\n      bytes: fromWords(words)\n    };\n  }\n\n  return {\n    encode,\n    decode,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords\n  };\n}\n\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n  encode: data => new TextDecoder().decode(data),\n  decode: str => new TextEncoder().encode(str)\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(s => {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n  return s.toLowerCase();\n}));\nconst CODERS = {\n  utf8: exports.utf8,\n  hex: exports.hex,\n  base16: exports.base16,\n  base32: exports.base32,\n  base64: exports.base64,\n  base64url: exports.base64url,\n  base58: exports.base58,\n  base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\n\nconst bytesToString = (type, bytes) => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\n\nconst stringToBytes = (type, str) => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;","map":{"version":3,"names":["Object","defineProperty","exports","value","bytes","stringToBytes","str","bytesToString","hex","utf8","bech32m","bech32","base58check","base58xmr","base58xrp","base58flickr","base58","base64url","base64","base32crockford","base32hex","base32","base16","utils","assertNumber","n","Number","isSafeInteger","Error","chain","wrap","a","b","c","args","encode","Array","from","reverse","reduce","acc","i","undefined","decode","alphabet","digits","isArray","length","map","input","letter","index","indexOf","join","separator","to","split","padding","bits","chr","data","push","end","slice","normalize","fn","convertRadix","pos","res","forEach","d","carry","done","digit","digitBase","Math","floor","gcd","radix2carry","convertRadix2","mask","radix","num","Uint8Array","radix2","revPadding","unsafeWrapper","apply","e","checksum","len","set","payload","newChecksum","oldChecksum","s","toUpperCase","replace","genBase58","abc","XMR_BLOCK_LEN","block","subarray","padStart","blockLen","j","concat","sha256","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","actualLength","TypeError","toLowerCase","lowered","sepIndex","lastIndexOf","sum","endsWith","decodeUnsafe","decodeToBytes","TextDecoder","TextEncoder","CODERS","coderTypeError","keys","type","hasOwnProperty"],"sources":["D:/Projects/NovaMiningverse/Nova-Miningverse/nova-miningverse-frontend/node_modules/@scure/base/lib/index.js"],"sourcesContent":["\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}