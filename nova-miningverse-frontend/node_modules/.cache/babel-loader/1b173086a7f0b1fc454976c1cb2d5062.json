{"ast":null,"code":"import { Buffer, getGlobalObject, makeUUID4, nextMonth } from '@stacks/common';\nimport { decryptECIES, encryptECIES, makeECPrivateKey, publicKeyToAddress } from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\nconst VERSION = '1.4.0';\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\nexport function makeAuthRequest(transitPrivateKey, redirectURI, manifestURI) {\n  let scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_SCOPE.slice();\n  let appDomain = arguments.length > 4 ? arguments[4] : undefined;\n  let expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextMonth().getTime();\n  let extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  const getWindowOrigin = paramName => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`\n    });\n    return location === null || location === void 0 ? void 0 : location.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\nexport async function encryptPrivateKey(publicKey, privateKey) {\n  const encryptedObj = await encryptECIES(publicKey, Buffer.from(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return Buffer.from(encryptedJSON).toString('hex');\n}\nexport async function decryptPrivateKey(privateKey, hexedEncrypted) {\n  const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\nexport async function makeAuthResponse(privateKey) {\n  let profile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let metadata = arguments.length > 2 ? arguments[2] : undefined;\n  let coreToken = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let appPrivateKey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextMonth().getTime();\n  let transitPublicKey = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n  let hubUrl = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  let blockstackAPIUrl = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  let associationToken = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  let appPrivateKeyFromWalletSalt = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToAddress(publicKey);\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n\n    additionalProperties = {\n      email: (metadata === null || metadata === void 0 ? void 0 : metadata.email) ? metadata.email : null,\n      profile_url: (metadata === null || metadata === void 0 ? void 0 : metadata.profileUrl) ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION\n    };\n  } else {}\n\n  const payload = Object.assign({}, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    appPrivateKeyFromWalletSalt,\n    profile,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}","map":{"version":3,"mappings":"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","names":["Buffer","getGlobalObject","makeUUID4","nextMonth","decryptECIES","encryptECIES","makeECPrivateKey","publicKeyToAddress","SECP256K1Client","TokenSigner","DEFAULT_SCOPE","makeDIDFromAddress","VERSION","generateTransitKey","transitKey","makeAuthRequest","transitPrivateKey","redirectURI","manifestURI","scopes","slice","appDomain","expiresAt","getTime","extraParams","getWindowOrigin","paramName","location","throwIfUnavailable","usageDesc","origin","payload","Object","assign","jti","iat","Math","floor","Date","exp","iss","public_keys","domain_name","manifest_uri","redirect_uri","version","do_not_include_profile","supports_hub_url","publicKey","derivePublicKey","address","tokenSigner","token","sign","encryptPrivateKey","privateKey","encryptedObj","from","encryptedJSON","JSON","stringify","toString","decryptPrivateKey","hexedEncrypted","unhexedString","parse","decrypted","Error","makeAuthResponse","profile","metadata","coreToken","appPrivateKey","transitPublicKey","hubUrl","blockstackAPIUrl","associationToken","appPrivateKeyFromWalletSalt","privateKeyPayload","coreTokenPayload","additionalProperties","undefined","email","profile_url","profileUrl","private_key","core_token"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\auth\\src\\messages.ts"],"sourcesContent":["import { Buffer, getGlobalObject, makeUUID4, nextMonth } from '@stacks/common';\nimport {\n  decryptECIES,\n  encryptECIES,\n  makeECPrivateKey,\n  publicKeyToAddress,\n} from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { AuthScope, DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\n\nconst VERSION = '1.4.0';\n\ntype AuthMetadata = {\n  email?: string;\n  profileUrl?: string;\n};\n\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\n\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {(AuthScope | string)[]} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\nexport function makeAuthRequest(\n  transitPrivateKey: string,\n  redirectURI?: string,\n  manifestURI?: string,\n  scopes: (AuthScope | string)[] = DEFAULT_SCOPE.slice(),\n  appDomain?: string,\n  expiresAt: number = nextMonth().getTime(),\n  extraParams: any = {}\n): string {\n  const getWindowOrigin = (paramName: string) => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`,\n    });\n    return location?.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  /* Create the payload */\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n    exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes,\n  });\n\n  // Logger.info(`blockstack.js: generating v${VERSION} auth request`)\n\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n\n  return token;\n}\n\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\nexport async function encryptPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n  const encryptedObj = await encryptECIES(publicKey, Buffer.from(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return Buffer.from(encryptedJSON).toString('hex');\n}\n\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\nexport async function decryptPrivateKey(\n  privateKey: string,\n  hexedEncrypted: string\n): Promise<string | null> {\n  const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\nexport async function makeAuthResponse(\n  privateKey: string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  profile: {} = {},\n  metadata: AuthMetadata | null,\n  coreToken: string | null = null,\n  appPrivateKey: string | null = null,\n  expiresAt: number = nextMonth().getTime(),\n  transitPublicKey: string | null = null,\n  hubUrl: string | null = null,\n  blockstackAPIUrl: string | null = null,\n  associationToken: string | null = null,\n  appPrivateKeyFromWalletSalt: string | null = null\n): Promise<string> {\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToAddress(publicKey);\n\n  /* See if we should encrypt with the transit key */\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    // Logger.info(`blockstack.js: generating v${VERSION} auth response`)\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION,\n    };\n  } else {\n    // Logger.info('blockstack.js: generating legacy auth response')\n  }\n\n  /* Create the payload */\n  const payload = Object.assign(\n    {},\n    {\n      jti: makeUUID4(),\n      iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n      exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n      iss: makeDIDFromAddress(address),\n      private_key: privateKeyPayload,\n      public_keys: [publicKey],\n      appPrivateKeyFromWalletSalt,\n      profile,\n      core_token: coreTokenPayload,\n    },\n    additionalProperties\n  );\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n"]},"metadata":{},"sourceType":"module"}