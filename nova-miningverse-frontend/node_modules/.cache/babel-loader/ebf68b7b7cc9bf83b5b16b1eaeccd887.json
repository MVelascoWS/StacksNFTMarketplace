{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\nexport function cvToString(val) {\n  let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n\n    case ClarityType.BoolFalse:\n      return 'false';\n\n    case ClarityType.Int:\n      return val.value.toString();\n\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n\n      return `0x${val.buffer.toString('hex')}`;\n\n    case ClarityType.OptionalNone:\n      return 'none';\n\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${cvToString(val.data[key], encoding)})`).join(' ')})`;\n\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\nexport function cvToValue(val) {\n  let strictJsonCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n\n    case ClarityType.BoolFalse:\n      return false;\n\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      } else {\n        return val.value;\n      }\n\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n\n    case ClarityType.OptionalNone:\n      return null;\n\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n\n    case ClarityType.Tuple:\n      const result = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n\n    case ClarityType.StringASCII:\n      return val.data;\n\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\nexport function cvToJSON(val) {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: false\n      };\n\n    case ClarityType.ResponseOk:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true),\n        success: true\n      };\n\n    default:\n      return {\n        type: getCVTypeString(val),\n        value: cvToValue(val, true)\n      };\n  }\n}\nexport function getCVTypeString(val) {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n\n    case ClarityType.Int:\n      return 'int';\n\n    case ClarityType.UInt:\n      return 'uint';\n\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n\n    case ClarityType.List:\n      return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;\n\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data).map(key => `(${key} ${getCVTypeString(val.data[key])})`).join(' ')})`;\n\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","principalToString","ClarityType","cvToString","val","encoding","type","BoolTrue","BoolFalse","Int","value","toString","UInt","str","buffer","test","JSON","stringify","OptionalNone","OptionalSome","ResponseErr","ResponseOk","PrincipalStandard","PrincipalContract","List","list","map","v","join","Tuple","Object","keys","data","key","StringASCII","StringUTF8","cvToValue","strictJsonCompat","cvToJSON","result","forEach","getCVTypeString","success","length","from"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\clarity\\clarityValue.ts"],"sourcesContent":["import { Buffer } from '@stacks/common';\nimport {\n  BooleanCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n  NoneCV,\n  SomeCV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { ClarityType } from './constants';\n\nexport type ClarityValue =\n  | BooleanCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | NoneCV\n  | SomeCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\n/**\n * @param strictJsonCompat If true then ints and uints are returned as JSON serializable numbers when\n * less than or equal to 53 bit length, otherwise string wrapped integers when larger than 53 bits.\n * If false, they are returned as js native `bigint`s which are _not_ JSON serializable.\n */\nexport function cvToValue(val: ClarityValue, strictJsonCompat: boolean = false): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      if (strictJsonCompat) {\n        return val.value.toString();\n      } else {\n        return val.value;\n      }\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val, true) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${\n        val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'\n      })`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}