{"ast":null,"code":"import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { Buffer, bytesToHex, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { deserializeCV, serializeCV } from './clarity';\nexport { verify as verifySignature } from '@noble/secp256k1';\nexport const randomBytes = bytesLength => Buffer.from(utils.randomBytes(bytesLength));\nexport { bytesToHex };\nexport class BufferArray {\n  constructor() {\n    this._value = [];\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  appendHexString(hexString) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer) {\n    return this._value.push(buffer);\n  }\n\n  appendByte(octet) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(`Value ${octet} is not a valid byte`);\n    }\n\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer() {\n    return Buffer.concat(this.value);\n  }\n\n}\nexport const leftPadHex = hexString => hexString.length % 2 == 0 ? hexString : `0${hexString}`;\nexport const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');\nexport const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');\nexport const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? Buffer.from(string).length > maxLengthBytes : false;\nexport function cloneDeep(obj) {\n  return lodashCloneDeep(obj);\n}\nexport function omit(obj, prop) {\n  const clone = cloneDeep(obj);\n  delete clone[prop];\n  return clone;\n}\nexport const txidFromData = data => {\n  return Buffer.from(sha512_256(data)).toString('hex');\n};\nexport const hash160 = input => {\n  return Buffer.from(ripemd160(sha256(input)));\n};\nexport const hashP2PKH = input => {\n  return hash160(input).toString('hex');\n};\nexport const hashP2WPKH = input => {\n  const keyHash = hash160(input);\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(keyHash.length);\n  bufferArray.push(keyHash);\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\nexport const hashP2SH = (numSigs, pubKeys) => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(80 + numSigs);\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  bufferArray.appendByte(80 + pubKeys.length);\n  bufferArray.appendByte(174);\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\nexport const hashP2WSH = (numSigs, pubKeys) => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n\n  const scriptArray = new BufferArray();\n  scriptArray.appendByte(80 + numSigs);\n  pubKeys.forEach(pubKey => {\n    scriptArray.appendByte(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  scriptArray.appendByte(80 + pubKeys.length);\n  scriptArray.appendByte(174);\n  const script = scriptArray.concatBuffer();\n  const digest = Buffer.from(sha256(script));\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(digest.length);\n  bufferArray.push(digest);\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\nexport function isClarityName(name) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\nexport function cvToHex(cv) {\n  const serialized = serializeCV(cv);\n  return `0x${serialized.toString('hex')}`;\n}\nexport function hexToCV(hex) {\n  return deserializeCV(hex);\n}\nexport const parseReadOnlyResponse = response => {\n  if (response.okay) {\n    return hexToCV(response.result);\n  } else {\n    throw new Error(response.cause);\n  }\n};\nexport const validateStacksAddress = stacksAddress => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nexport const validateTxId = txid => {\n  if (txid === 'success') return true;\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};","map":{"version":3,"mappings":"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","names":["ripemd160","sha256","sha512_256","utils","Buffer","bytesToHex","with0x","c32addressDecode","lodashCloneDeep","deserializeCV","serializeCV","verify","verifySignature","randomBytes","bytesLength","from","BufferArray","constructor","value","_value","appendHexString","hexString","push","buffer","appendByte","octet","Number","isInteger","Error","concatBuffer","concat","leftPadHex","length","leftPadHexToLength","padStart","rightPadHexToLength","padEnd","exceedsMaxLengthBytes","string","maxLengthBytes","cloneDeep","obj","omit","prop","clone","txidFromData","data","toString","hash160","input","hashP2PKH","hashP2WPKH","keyHash","bufferArray","redeemScript","redeemScriptHash","hashP2SH","numSigs","pubKeys","forEach","pubKey","hashP2WSH","scriptArray","script","digest","isClarityName","name","regex","test","cvToHex","cv","serialized","hexToCV","hex","parseReadOnlyResponse","response","okay","result","cause","validateStacksAddress","stacksAddress","e","validateTxId","txid","toLowerCase","BigInt"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\transactions\\src\\utils.ts"],"sourcesContent":["import { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512_256 } from '@noble/hashes/sha512';\nimport { utils } from '@noble/secp256k1';\nimport { Buffer, bytesToHex, with0x } from '@stacks/common';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash.clonedeep';\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity';\n\n// Export verify as utility method for signature verification\nexport { verify as verifySignature } from '@noble/secp256k1';\n\n/**\n * Use utils.randomBytes to replace randombytes dependency\n * Generates a buffer with random bytes of given length\n * @param {bytesLength} an optional bytes length, default is 32 bytes\n * @return {Buffer} For return type compatibility converting utils.randomBytes return value to buffer\n */\nexport const randomBytes = (bytesLength?: number) => Buffer.from(utils.randomBytes(bytesLength));\n\n/**\n * @deprecated Import from `@stacks/common` instead\n */\nexport { bytesToHex };\n\nexport class BufferArray {\n  _value: Buffer[] = [];\n  get value() {\n    return this._value;\n  }\n  appendHexString(hexString: string) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer: Buffer) {\n    return this._value.push(buffer);\n  }\n  appendByte(octet: number) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(`Value ${octet} is not a valid byte`);\n    }\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer(): Buffer {\n    return Buffer.concat(this.value);\n  }\n}\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? Buffer.from(string).length > maxLengthBytes : false;\n\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport const txidFromData = (data: Buffer): string => {\n  return Buffer.from(sha512_256(data)).toString('hex');\n};\n\nexport const hash160 = (input: Buffer): Buffer => {\n  return Buffer.from(ripemd160(sha256(input)));\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\nexport const hashP2PKH = (input: Buffer): string => {\n  return hash160(input).toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address over p2sh (p2h-p2wpkh)\nexport const hashP2WPKH = (input: Buffer): string => {\n  const keyHash = hash160(input);\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(keyHash.length);\n  bufferArray.push(keyHash);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\nexport const hashP2SH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bufferArray = new BufferArray();\n  // OP_n\n  bufferArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  // OP_m\n  bufferArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bufferArray.appendByte(174);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multisig address over p2sh (p2sh-p2wsh)\nexport const hashP2WSH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2WSH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const scriptArray = new BufferArray();\n  // OP_n\n  scriptArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    scriptArray.appendByte(pubKey.length);\n    scriptArray.push(pubKey);\n  });\n  // OP_m\n  scriptArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  scriptArray.appendByte(174);\n\n  const script = scriptArray.concatBuffer();\n  const digest = Buffer.from(sha256(script));\n\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(0);\n  bufferArray.appendByte(digest.length);\n  bufferArray.push(digest);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${serialized.toString('hex')}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  return deserializeCV(hex);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionSuccessResponse {\n  okay: true;\n  result: string;\n}\n\nexport interface ReadOnlyFunctionErrorResponse {\n  okay: false;\n  cause: string;\n}\n\nexport type ReadOnlyFunctionResponse =\n  | ReadOnlyFunctionSuccessResponse\n  | ReadOnlyFunctionErrorResponse;\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = (response: ReadOnlyFunctionResponse): ClarityValue => {\n  if (response.okay) {\n    return hexToCV(response.result);\n  } else {\n    throw new Error(response.cause);\n  }\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nexport const validateTxId = (txid: string): boolean => {\n  if (txid === 'success') return true; // Bypass fetchMock tests\n  const value = with0x(txid).toLowerCase();\n  if (value.length !== 66) return false;\n  return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;\n};\n"]},"metadata":{},"sourceType":"module"}