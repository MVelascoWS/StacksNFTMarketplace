{"ast":null,"code":"import * as queryString from 'query-string';\nimport { decodeToken } from 'jsontokens';\nimport { BLOCKSTACK_HANDLER, getGlobalObject } from '@stacks/common';\nimport { createFetchFn } from '@stacks/network';\nexport function getAuthRequestFromURL() {\n  const location = getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthRequestFromURL'\n  });\n\n  if (location === null || location === void 0 ? void 0 : location.search) {\n    const queryDict = queryString.parse(location === null || location === void 0 ? void 0 : location.search);\n\n    if (queryDict.authRequest) {\n      return queryDict.authRequest.split(`${BLOCKSTACK_HANDLER}:`).join('');\n    } else {\n      return null;\n    }\n  } else {\n    return null;\n  }\n}\nexport async function fetchAppManifest(authRequest) {\n  let fetchFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createFetchFn();\n\n  if (!authRequest) {\n    throw new Error('Invalid auth request');\n  }\n\n  const payload = decodeToken(authRequest).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const manifestURI = payload.manifest_uri;\n\n  try {\n    const response = await fetchFn(manifestURI);\n    const responseText = await response.text();\n    const responseJSON = JSON.parse(responseText);\n    return Object.assign(Object.assign({}, responseJSON), {\n      manifestURI\n    });\n  } catch (error) {\n    console.log(error);\n    throw new Error('Could not fetch manifest.json');\n  }\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,WAAZ,MAA6B,cAA7B;AACA,SAASC,WAAT,QAA4B,YAA5B;AACA,SAASC,kBAAT,EAA6BC,eAA7B,QAAoD,gBAApD;AACA,SAASC,aAAT,QAAuC,iBAAvC;AASA,OAAM,SAAUC,qBAAV,GAA+B;EACnC,MAAMC,QAAQ,GAAGH,eAAe,CAAC,UAAD,EAAa;IAC3CI,kBAAkB,EAAE,IADuB;IAE3CC,SAAS,EAAE;EAFgC,CAAb,CAAhC;;EAIA,IAAIF,QAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAEG,MAAd,EAAsB;IACpB,MAAMC,SAAS,GAAGV,WAAW,CAACW,KAAZ,CAAkBL,QAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAEG,MAA5B,CAAlB;;IACA,IAAIC,SAAS,CAACE,WAAd,EAA2B;MACzB,OAAQF,SAAS,CAACE,WAAV,CAAiCC,KAAjC,CAAuC,GAAGX,kBAAkB,GAA5D,EAAiEY,IAAjE,CAAsE,EAAtE,CAAR;IACD,CAFD,MAEO;MACL,OAAO,IAAP;IACD;EACF,CAPD,MAOO;IACL,OAAO,IAAP;EACD;AACF;AAYD,OAAO,eAAeC,gBAAf,CACLH,WADK,EAE6B;EAAA,IAAlCI,OAAkC,uEAAfZ,aAAa,EAAE;;EAElC,IAAI,CAACQ,WAAL,EAAkB;IAChB,MAAM,IAAIK,KAAJ,CAAU,sBAAV,CAAN;EACD;;EACD,MAAMC,OAAO,GAAGjB,WAAW,CAACW,WAAD,CAAX,CAAyBM,OAAzC;;EACA,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;IAC/B,MAAM,IAAID,KAAJ,CAAU,yCAAV,CAAN;EACD;;EACD,MAAME,WAAW,GAAGD,OAAO,CAACE,YAA5B;;EACA,IAAI;IAEF,MAAMC,QAAQ,GAAG,MAAML,OAAO,CAACG,WAAD,CAA9B;IACA,MAAMG,YAAY,GAAG,MAAMD,QAAQ,CAACE,IAAT,EAA3B;IACA,MAAMC,YAAY,GAAGC,IAAI,CAACd,KAAL,CAAWW,YAAX,CAArB;IACA,uCAAYE,YAAZ,GAAwB;MAAEL;IAAF,CAAxB;EACD,CAND,CAME,OAAOO,KAAP,EAAc;IACdC,OAAO,CAACC,GAAR,CAAYF,KAAZ;IACA,MAAM,IAAIT,KAAJ,CAAU,+BAAV,CAAN;EACD;AACF","names":["queryString","decodeToken","BLOCKSTACK_HANDLER","getGlobalObject","createFetchFn","getAuthRequestFromURL","location","throwIfUnavailable","usageDesc","search","queryDict","parse","authRequest","split","join","fetchAppManifest","fetchFn","Error","payload","manifestURI","manifest_uri","response","responseText","text","responseJSON","JSON","error","console","log"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\auth\\src\\provider.ts"],"sourcesContent":["import * as queryString from 'query-string';\nimport { decodeToken } from 'jsontokens';\nimport { BLOCKSTACK_HANDLER, getGlobalObject } from '@stacks/common';\nimport { createFetchFn, FetchFn } from '@stacks/network';\n\n/**\n * Retrieves the authentication request from the query string\n * @return {String|null} the authentication request or `null` if\n * the query string parameter `authRequest` is not found\n * @private\n * @ignore\n */\nexport function getAuthRequestFromURL() {\n  const location = getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthRequestFromURL',\n  });\n  if (location?.search) {\n    const queryDict = queryString.parse(location?.search);\n    if (queryDict.authRequest) {\n      return (queryDict.authRequest as string).split(`${BLOCKSTACK_HANDLER}:`).join('');\n    } else {\n      return null;\n    }\n  } else {\n    return null;\n  }\n}\n\n/**\n * Fetches the contents of the manifest file specified in the authentication request\n *\n * @param  {String} authRequest encoded and signed authentication request\n * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON\n * object manifest file unless there's an error in which case rejects with an error\n * message.\n * @private\n * @ignore\n */\nexport async function fetchAppManifest(\n  authRequest: string,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<any> {\n  if (!authRequest) {\n    throw new Error('Invalid auth request');\n  }\n  const payload = decodeToken(authRequest).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const manifestURI = payload.manifest_uri as string;\n  try {\n    // Logger.debug(`Fetching manifest from ${manifestURI}`)\n    const response = await fetchFn(manifestURI);\n    const responseText = await response.text();\n    const responseJSON = JSON.parse(responseText);\n    return { ...responseJSON, manifestURI };\n  } catch (error) {\n    console.log(error);\n    throw new Error('Could not fetch manifest.json');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}