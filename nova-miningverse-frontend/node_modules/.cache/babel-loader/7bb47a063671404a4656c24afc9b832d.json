{"ast":null,"code":"import { AppConfig } from './appConfig';\nimport { InstanceDataStore, LocalStorageStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport { decryptContent, encryptContent, isValidPrivateKey } from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, getGlobalObject, InvalidStateError, isLaterVersion, Logger, LoginFailedError, MissingParameterError, nextHour } from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { DEFAULT_PROFILE } from './constants';\nimport * as queryString from 'query-string';\nimport { createFetchFn, StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\nexport class UserSession {\n  constructor(options) {\n    let runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain) {\n    let expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextHour().getTime();\n    let extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    const appConfig = this.appConfig;\n\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n  }\n\n  generateAndStoreTransitKey() {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n\n  getAuthResponseToken() {\n    var _a;\n\n    const search = (_a = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken'\n    })) === null || _a === void 0 ? void 0 : _a.search;\n\n    if (search) {\n      const queryDict = queryString.parse(search);\n      return queryDict.authResponse ? queryDict.authResponse : '';\n    }\n\n    return '';\n  }\n\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n\n      if (isProtocolEcho) {\n        Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n\n    return !!this.getAuthResponseToken();\n  }\n\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n\n  async handlePendingSignIn() {\n    let authResponseToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAuthResponseToken();\n    let fetchFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createFetchFn();\n    const sessionData = this.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n\n    const transitKey = this.store.getSessionData().transitKey;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.bnsLookupUrl;\n    }\n\n    const tokenPayload = decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const isValid = await verifyAuthResponse(authResponseToken);\n\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n\n    let appPrivateKey = tokenPayload.private_key;\n    let coreSessionToken = tokenPayload.core_token;\n\n    if (isLaterVersion(tokenPayload.version, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = await authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key);\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n\n            if (!isValidPrivateKey(tokenPayload.private_key)) {\n              throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n            }\n          }\n        }\n\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = await authMessages.decryptPrivateKey(transitKey, coreSessionToken);\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n      }\n    }\n\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken;\n\n    if (isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n      hubUrl = tokenPayload.hubUrl;\n    }\n\n    if (isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n      gaiaAssociationToken = tokenPayload.associationToken;\n    }\n\n    const userData = {\n      profile: tokenPayload.profile,\n      email: tokenPayload.email,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt,\n      coreNode: tokenPayload.blockstackAPIUrl,\n      gaiaAssociationToken\n    };\n    const profileURL = tokenPayload.profile_url;\n\n    if (!userData.profile && profileURL) {\n      const response = await fetchFn(profileURL);\n\n      if (!response.ok) {\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n    return userData;\n  }\n\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n\n    return userData;\n  }\n\n  encryptContent(content, options) {\n    const opts = Object.assign({}, options);\n\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n\n    return encryptContent(content, opts);\n  }\n\n  decryptContent(content, options) {\n    const opts = Object.assign({}, options);\n\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n\n    return decryptContent(content, opts);\n  }\n\n  signUserOut(redirectURL) {\n    this.store.deleteSessionData();\n\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["AppConfig","InstanceDataStore","LocalStorageStore","decodeToken","verifyAuthResponse","authMessages","decryptContent","encryptContent","isValidPrivateKey","getAddressFromDID","BLOCKSTACK_DEFAULT_GAIA_HUB_URL","getGlobalObject","InvalidStateError","isLaterVersion","Logger","LoginFailedError","MissingParameterError","nextHour","extractProfile","DEFAULT_PROFILE","queryString","createFetchFn","StacksMainnet","protocolEchoReplyDetection","UserSession","constructor","options","runningInBrowser","window","self","appConfig","sessionStore","store","sessionOptions","makeAuthRequest","transitKey","redirectURI","manifestURI","scopes","appDomain","expiresAt","getTime","extraParams","generateAndStoreTransitKey","sessionData","getSessionData","generateTransitKey","setSessionData","getAuthResponseToken","search","throwIfUnavailable","usageDesc","_a","queryDict","parse","authResponse","isSignInPending","isProtocolEcho","info","error","isUserSignedIn","userData","handlePendingSignIn","authResponseToken","fetchFn","coreNode","network","bnsLookupUrl","tokenPayload","payload","Error","isValid","appPrivateKey","private_key","coreSessionToken","core_token","version","undefined","decryptPrivateKey","e","warn","hubUrl","gaiaAssociationToken","associationToken","profile","email","decentralizedID","iss","identityAddress","appPrivateKeyFromWalletSalt","blockstackAPIUrl","profileURL","profile_url","response","ok","Object","assign","responseText","text","wrappedProfile","JSON","token","loadUserData","content","opts","privateKey","signUserOut","redirectURL","deleteSessionData","location","href"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\auth\\src\\userSession.ts"],"sourcesContent":["// @ts-ignore\nimport { Buffer } from '@stacks/common';\nimport { AppConfig } from './appConfig';\nimport { SessionOptions } from './sessionData';\nimport { InstanceDataStore, LocalStorageStore, SessionDataStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport {\n  decryptContent,\n  encryptContent,\n  EncryptContentOptions,\n  isValidPrivateKey,\n} from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport {\n  BLOCKSTACK_DEFAULT_GAIA_HUB_URL,\n  getGlobalObject,\n  InvalidStateError,\n  isLaterVersion,\n  Logger,\n  LoginFailedError,\n  MissingParameterError,\n  nextHour,\n} from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { AuthScope, DEFAULT_PROFILE } from './constants';\nimport * as queryString from 'query-string';\nimport { UserData } from './userData';\nimport { createFetchFn, FetchFn, StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\n\n/**\n *\n * Represents an instance of a signed in user for a particular app.\n *\n * A signed in user has access to two major pieces of information\n * about the user, the user's private key for that app and the location\n * of the user's gaia storage bucket for the app.\n *\n * A user can be signed in either directly through the interactive\n * sign in process or by directly providing the app private key.\n *\n\n *\n */\nexport class UserSession {\n  appConfig: AppConfig;\n\n  store: SessionDataStore;\n\n  /**\n   * Creates a UserSession object\n   *\n   * @param options\n   */\n  constructor(options?: {\n    appConfig?: AppConfig;\n    sessionStore?: SessionDataStore;\n    sessionOptions?: SessionOptions;\n  }) {\n    let runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      // Logger.debug('UserSession: not running in browser')\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  /**\n   * Generates an authentication request that can be sent to the Blockstack\n   * browser for the user to approve sign in. This authentication request can\n   * then be used for sign in by passing it to the [[redirectToSignInWithAuthRequest]]\n   * method.\n   *\n   * *Note*: This method should only be used if you want to use a customized authentication\n   * flow. Typically, you'd use [[redirectToSignIn]] which is the default sign in method.\n   *\n   * @param transitKey A HEX encoded transit private key.\n   * @param redirectURI Location to redirect the user to after sign in approval.\n   * @param manifestURI Location of this app's manifest file.\n   * @param scopes The permissions this app is requesting. The default is `store_write`.\n   * @param appDomain The origin of the app.\n   * @param expiresAt The time at which this request is no longer valid.\n   * @param extraParams Any extra parameters to pass to the authenticator. Use this to\n   * pass options that aren't part of the Blockstack authentication specification,\n   * but might be supported by special authenticators.\n   *\n   * @returns {String} the authentication request\n   */\n  makeAuthRequest(\n    transitKey?: string,\n    redirectURI?: string,\n    manifestURI?: string,\n    scopes?: (AuthScope | string)[],\n    appDomain?: string,\n    expiresAt: number = nextHour().getTime(),\n    extraParams: any = {}\n  ): string {\n    const appConfig = this.appConfig;\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequest(\n      transitKey,\n      redirectURI,\n      manifestURI,\n      scopes,\n      appDomain,\n      expiresAt,\n      extraParams\n    );\n  }\n\n  /**\n   * Generates a ECDSA keypair to\n   * use as the ephemeral app transit private key\n   * and store in the session.\n   *\n   * @returns {String} the hex encoded private key\n   *\n   */\n  generateAndStoreTransitKey(): string {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n\n  /**\n   * Retrieve the authentication token from the URL query\n   * @return {String} the authentication token if it exists otherwise `null`\n   */\n  getAuthResponseToken(): string {\n    const search = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken',\n    })?.search;\n    if (search) {\n      const queryDict = queryString.parse(search);\n      return queryDict.authResponse ? (queryDict.authResponse as string) : '';\n    }\n    return '';\n  }\n\n  /**\n   * Check if there is a authentication request that hasn't been handled.\n   *\n   * Also checks for a protocol echo reply (which if detected then the page\n   * will be automatically redirected after this call).\n   *\n   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n   */\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n      if (isProtocolEcho) {\n        Logger.info(\n          'protocolEchoReply detected from isSignInPending call, the page is about to redirect.'\n        );\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n\n    return !!this.getAuthResponseToken();\n  }\n\n  /**\n   * Check if a user is currently signed in.\n   *\n   * @returns {Boolean} `true` if the user is signed in, `false` if not.\n   */\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n\n  /**\n   * Try to process any pending sign in request by returning a `Promise` that resolves\n   * to the user data object if the sign in succeeds.\n   *\n   * @param {String} authResponseToken - the signed authentication response token\n   * @returns {Promise} that resolves to the user data object if successful and rejects\n   * if handling the sign in request fails or there was no pending sign in request.\n   */\n  async handlePendingSignIn(\n    authResponseToken: string = this.getAuthResponseToken(),\n    fetchFn: FetchFn = createFetchFn()\n  ): Promise<UserData> {\n    const sessionData = this.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n\n    const transitKey = this.store.getSessionData().transitKey;\n\n    // let nameLookupURL;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.bnsLookupUrl;\n    }\n\n    const tokenPayload = decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const isValid = await verifyAuthResponse(authResponseToken);\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n\n    // TODO: real version handling\n    let appPrivateKey: string = tokenPayload.private_key as string;\n    let coreSessionToken: string = tokenPayload.core_token as string;\n    if (isLaterVersion(tokenPayload.version as string, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = (await authMessages.decryptPrivateKey(\n              transitKey,\n              tokenPayload.private_key as string\n            )) as string;\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            if (!isValidPrivateKey(tokenPayload.private_key as string)) {\n              throw new LoginFailedError(\n                'Failed decrypting appPrivateKey. Usually means' +\n                  ' that the transit key has changed during login.'\n              );\n            }\n          }\n        }\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = (await authMessages.decryptPrivateKey(\n              transitKey,\n              coreSessionToken\n            )) as string;\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError(\n          'Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.'\n        );\n      }\n    }\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken: string;\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.2.0') &&\n      tokenPayload.hubUrl !== null &&\n      tokenPayload.hubUrl !== undefined\n    ) {\n      hubUrl = tokenPayload.hubUrl as string;\n    }\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.3.0') &&\n      tokenPayload.associationToken !== null &&\n      tokenPayload.associationToken !== undefined\n    ) {\n      gaiaAssociationToken = tokenPayload.associationToken as string;\n    }\n\n    const userData: UserData = {\n      profile: tokenPayload.profile,\n      email: tokenPayload.email as string,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt as string,\n      coreNode: tokenPayload.blockstackAPIUrl as string,\n      // @ts-expect-error\n      gaiaAssociationToken,\n    };\n    const profileURL = tokenPayload.profile_url as string;\n    if (!userData.profile && profileURL) {\n      const response = await fetchFn(profileURL);\n      if (!response.ok) {\n        // return blank profile if we fail to fetch\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n\n    return userData;\n  }\n\n  /**\n   * Retrieves the user data object. The user's profile is stored in the key [[Profile]].\n   *\n   * @returns {Object} User data object.\n   */\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n    return userData;\n  }\n\n  /**\n   * Encrypts the data provided with the app public key.\n   * @param {String|Buffer} content  the data to encrypt\n   * @param options\n   * @param {String} options.publicKey the hex string of the ECDSA public\n   * key to use for encryption. If not provided, will use user's appPrivateKey.\n   *\n   * @returns {String} Stringified ciphertext object\n   */\n  encryptContent(content: string | Buffer, options?: EncryptContentOptions): Promise<string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return encryptContent(content, opts);\n  }\n\n  /**\n   * Decrypts data encrypted with `encryptContent` with the\n   * transit private key.\n   * @param {String|Buffer} content - encrypted content.\n   * @param options\n   * @param {String} options.privateKey - The hex string of the ECDSA private\n   * key to use for decryption. If not provided, will use user's appPrivateKey.\n   * @returns {String|Buffer} decrypted content.\n   */\n  decryptContent(content: string, options?: { privateKey?: string }): Promise<Buffer | string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return decryptContent(content, opts);\n  }\n\n  /**\n   * Sign the user out and optionally redirect to given location.\n   * @param  redirectURL\n   * Location to redirect user to after sign out.\n   * Only used in environments with `window` available\n   */\n\n  signUserOut(\n    redirectURL?: string\n    // TODO: this is not used?\n    // caller?: UserSession\n  ) {\n    this.store.deleteSessionData();\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n      // TODO: Invalid left-hand side in assignment expression\n      // // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // // @ts-ignore\n      // getGlobalObject('location', {\n      //   throwIfUnavailable: true,\n      //   usageDesc: 'signUserOut',\n      // })?.href = redirectURL;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}