{"ast":null,"code":"import { sha256 } from '@noble/hashes/sha256';\nimport { Buffer } from '@stacks/common';\nimport { ClarityType, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv } from './keys';\nexport const STRUCTURED_DATA_PREFIX = Buffer.from('SIP018', 'ascii');\nexport function hashStructuredData(structuredData) {\n  return Buffer.from(sha256(serializeCV(structuredData)));\n}\nconst hash256BytesLength = 32;\n\nfunction isDomain(value) {\n  if (value.type !== ClarityType.Tuple) return false;\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII)) return false;\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData(_ref) {\n  let {\n    message,\n    domain\n  } = _ref;\n  const structuredDataHash = hashStructuredData(message);\n\n  if (!isDomain(domain)) {\n    throw new Error(\"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\");\n  }\n\n  const domainHash = hashStructuredData(domain);\n  return Buffer.concat([STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash]);\n}\nexport function decodeStructuredDataSignature(signature) {\n  const encodedMessageBuffer = Buffer.from(signature);\n  const domainHash = encodedMessageBuffer.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  const messageHash = encodedMessageBuffer.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash,\n    messageHash\n  };\n}\nexport function signStructuredData(_ref2) {\n  let {\n    message,\n    domain,\n    privateKey\n  } = _ref2;\n  const structuredDataHash = Buffer.from(sha256(encodeStructuredData({\n    message,\n    domain\n  }))).toString('hex');\n  const {\n    data\n  } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature\n  };\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAuB,sBAAvB;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,WAAT,EAAoCC,WAApC,QAAuD,WAAvD;AACA,SAASC,iBAAT,QAAkC,aAAlC;AACA,SAASC,kBAAT,QAAqD,QAArD;AAGA,OAAO,MAAMC,sBAAsB,GAAGL,MAAM,CAACM,IAAP,CAAY,QAAZ,EAAsB,OAAtB,CAA/B;AAEP,OAAM,SAAUC,kBAAV,CAA6BC,cAA7B,EAAyD;EAC7D,OAAOR,MAAM,CAACM,IAAP,CAAYP,MAAM,CAACG,WAAW,CAACM,cAAD,CAAZ,CAAlB,CAAP;AACD;AAED,MAAMC,kBAAkB,GAAG,EAA3B;;AAEA,SAASC,QAAT,CAAkBC,KAAlB,EAAqC;EACnC,IAAIA,KAAK,CAACC,IAAN,KAAeX,WAAW,CAACY,KAA/B,EAAsC,OAAO,KAAP;EAEtC,IAAI,CAAC,CAAC,MAAD,EAAS,SAAT,EAAoB,UAApB,EAAgCC,KAAhC,CAAsCC,GAAG,IAAIA,GAAG,IAAIJ,KAAK,CAACK,IAA1D,CAAL,EAAsE,OAAO,KAAP;EAEtE,IAAI,CAAC,CAAC,MAAD,EAAS,SAAT,EAAoBF,KAApB,CAA0BC,GAAG,IAAIJ,KAAK,CAACK,IAAN,CAAWD,GAAX,EAAgBH,IAAhB,KAAyBX,WAAW,CAACgB,WAAtE,CAAL,EACE,OAAO,KAAP;EAEF,IAAIN,KAAK,CAACK,IAAN,CAAW,UAAX,EAAuBJ,IAAvB,KAAgCX,WAAW,CAACiB,IAAhD,EAAsD,OAAO,KAAP;EACtD,OAAO,IAAP;AACD;;AAED,OAAM,SAAUC,oBAAV,OAML;EAAA,IANoC;IACnCC,OADmC;IAEnCC;EAFmC,CAMpC;EACC,MAAMC,kBAAkB,GAAWf,kBAAkB,CAACa,OAAD,CAArD;;EACA,IAAI,CAACV,QAAQ,CAACW,MAAD,CAAb,EAAuB;IACrB,MAAM,IAAIE,KAAJ,CACJ,sJADI,CAAN;EAGD;;EACD,MAAMC,UAAU,GAAWjB,kBAAkB,CAACc,MAAD,CAA7C;EAEA,OAAOrB,MAAM,CAACyB,MAAP,CAAc,CAACpB,sBAAD,EAAyBmB,UAAzB,EAAqCF,kBAArC,CAAd,CAAP;AACD;AAOD,OAAM,SAAUI,6BAAV,CAAwCC,SAAxC,EAAkE;EACtE,MAAMC,oBAAoB,GAAW5B,MAAM,CAACM,IAAP,CAAYqB,SAAZ,CAArC;EACA,MAAMH,UAAU,GAAGI,oBAAoB,CAACC,KAArB,CACjBxB,sBAAsB,CAACyB,MADN,EAEjBzB,sBAAsB,CAACyB,MAAvB,GAAgCrB,kBAFf,CAAnB;EAIA,MAAMsB,WAAW,GAAGH,oBAAoB,CAACC,KAArB,CAClBxB,sBAAsB,CAACyB,MAAvB,GAAgCrB,kBADd,CAApB;EAGA,OAAO;IACLe,UADK;IAELO;EAFK,CAAP;AAID;AAYD,OAAM,SAAUC,kBAAV,QAQL;EAAA,IARkC;IACjCZ,OADiC;IAEjCC,MAFiC;IAGjCY;EAHiC,CAQlC;EACC,MAAMX,kBAAkB,GAAWtB,MAAM,CAACM,IAAP,CACjCP,MAAM,CAACoB,oBAAoB,CAAC;IAAEC,OAAF;IAAWC;EAAX,CAAD,CAArB,CAD2B,EAEjCa,QAFiC,CAExB,KAFwB,CAAnC;EAIA,MAAM;IAAElB;EAAF,IAAWZ,kBAAkB,CAAC;IAClC2B,WAAW,EAAET,kBADqB;IAElCW;EAFkC,CAAD,CAAnC;EAIA,OAAO;IACLjB,IADK;IAELJ,IAAI,EAAET,iBAAiB,CAACgC;EAFnB,CAAP;AAID","names":["sha256","Buffer","ClarityType","serializeCV","StacksMessageType","signMessageHashRsv","STRUCTURED_DATA_PREFIX","from","hashStructuredData","structuredData","hash256BytesLength","isDomain","value","type","Tuple","every","key","data","StringASCII","UInt","encodeStructuredData","message","domain","structuredDataHash","Error","domainHash","concat","decodeStructuredDataSignature","signature","encodedMessageBuffer","slice","length","messageHash","signStructuredData","privateKey","toString","StructuredDataSignature"],"sources":["D:\\Projects\\NovaMiningverse\\Nova-Miningverse\\nova-miningverse-frontend\\node_modules\\@stacks\\connect\\node_modules\\@stacks\\transactions\\src\\structuredDataSignature.ts"],"sourcesContent":["import { sha256 } from '@noble/hashes/sha256';\nimport { Buffer } from '@stacks/common';\nimport { ClarityType, ClarityValue, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv, StacksPrivateKey } from './keys';\n\n// Refer to SIP018 https://github.com/stacksgov/sips/\nexport const STRUCTURED_DATA_PREFIX = Buffer.from('SIP018', 'ascii');\n\nexport function hashStructuredData(structuredData: ClarityValue): Buffer {\n  return Buffer.from(sha256(serializeCV(structuredData)));\n}\n\nconst hash256BytesLength = 32;\n\nfunction isDomain(value: ClarityValue): boolean {\n  if (value.type !== ClarityType.Tuple) return false;\n  // Check that the tuple has at least 'name', 'version' and 'chain-id'\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  // Check each key is of the right type\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))\n    return false;\n\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData({\n  message,\n  domain,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n}): Buffer {\n  const structuredDataHash: Buffer = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\n      \"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\"\n    );\n  }\n  const domainHash: Buffer = hashStructuredData(domain);\n\n  return Buffer.concat([STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash]);\n}\n\nexport type DecodedStructuredData = {\n  domainHash: Buffer;\n  messageHash: Buffer;\n};\n\nexport function decodeStructuredDataSignature(signature: string | Buffer): DecodedStructuredData {\n  const encodedMessageBuffer: Buffer = Buffer.from(signature);\n  const domainHash = encodedMessageBuffer.slice(\n    STRUCTURED_DATA_PREFIX.length,\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  const messageHash = encodedMessageBuffer.slice(\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  return {\n    domainHash,\n    messageHash,\n  };\n}\n\nexport interface StructuredDataSignature {\n  readonly type: StacksMessageType.StructuredDataSignature;\n  data: string;\n}\n\n/**\n * Signs a structured message (ClarityValue) and a domain (ClarityValue) using a private key.\n * The resulting signature along with the original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n  privateKey: StacksPrivateKey;\n}): StructuredDataSignature {\n  const structuredDataHash: string = Buffer.from(\n    sha256(encodeStructuredData({ message, domain }))\n  ).toString('hex');\n\n  const { data } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey,\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}